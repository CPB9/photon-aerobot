module grp

import core::{Reader, Writer, Error, Option}

type UavId = varuint;
type TermId = varuint;
type GrpId = varuint;
type EntryId = varuint;
type Index = varuint;

struct ReqVoteRep {
    term: TermId,
    vote: Option<bool>
}

enum EntryKind {
    Normal = 1,
    AddNonVotingNode = 2,
    AddNode = 3,
    DemoteNode = 4,
    RemoveNode = 5,
}

struct LogEntry {
    term: TermId,
    entryId: EntryId,
    kind: EntryKind,
    node: UavId,
}

struct ReqAppendEntryRep {
    term: TermId,
    success: bool,
    currentIdx: Index,
    firstIdx: Index
}

enum ReqErr {
    NotLeader = 1,
    NodeUnknown = 2,
    OneVotingChangeOnly = 3,
    Unknown = 4,
}

struct ReqCfgRep {
    err: Option<ReqErr>,
    term: TermId,
    id: EntryId,
    idx: Index
}

enum MemberState {
    Leader = 0,
    Candidate = 1,
    Follower = 2,
}


component {
    parameters {
        group: GrpId,
        members: &[UavId; 10],
        leader: Option<UavId>,
        state: MemberState,
        term: TermId,
        commit: Index,
        lastLogIdx: Index,
        lastLogTerm: TermId
        votedFor: Option<UavId>,
    }

    impl {
        fn init()
        fn tick()
        fn genRaftData(data: *mut void, writer: *mut Writer) -> Error
    }

    commands {
        fn setGroupAddress(address: varuint)
        fn addMember(group: GrpId, member: UavId) -> ReqCfgRep
        fn removeMember(group: GrpId, member: UavId) -> ReqCfgRep

        fn reqVote(term: TermId, lastLogIdx: Index, lastLogTerm: TermId) -> ReqVoteRep
        fn reqAppendEntry(term: TermId, prevLogIdx: Index, prevLogTerm: TermId, leaderCommit: Index, entries: &[LogEntry; 10]) -> ReqAppendEntryRep
    }
}
